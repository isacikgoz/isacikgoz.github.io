<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Go effect after 7 years with Java</title>
      <link href="/2018/12/31/golang/"/>
      <url>/2018/12/31/golang/</url>
      
        <content type="html"><![CDATA[<p>Recently, I’ve been working on some side projects to improve my Go skills. Since I have some close friends who are very active with Go, I was stoically observing their work along with the Go community. Hence, it was always an interesting topic for me. I don’t know when the exact time the spark is flamed but I found myself working on these side project after I came home from work till midnight. For a quick info, I’ve been working as a software engineer on a satellite ground station project. And I don’t have a single bit related to Go in my professional career. We use java, c++ and occasionally python.</p><p>So let’s return to the topic; the effect beneath Go. As far as I can see, Go is complicated at the begining if you have a solid java-style background. The language itself has a little awkward syntax. But in time, eventually, you are getting used to it. If I supposed to compare it with java, for a public function(method) you write;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Go on the other hand;<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>As you can see, even with the simplest code snippets, with a java point of view, it is not so easy to get used to this syntax. But this is the initial feeling though. Also, lack of object-oriented paradigms such as polymorphism etc. makes you look at the computer screen meaningless. So I thought that it would be a better practice to see other peoples work and try to undersetand how they use the the language in real life problems. I visited many open source Go projects and noticed that Go developers write code with the shortest possible variable names, shortest possible function names. Java devs on the other hand, tend to be more verbose. Java-like coding is like writing a literature book. Reading java code requires less learning curve. Go; hard to start easy to sustain. At the begining I was struggling to understand the code snippets but now I’m getting used to it. I’m sure that there are many writings about how Go has different syntax than X language or differences between functional programming and object-orinted programming. This comparison is a little out of my topic but still worth to mention a little.</p><p>My verdict on Go is that it is far more practical when it comes to create “something”. I mean, you have an idea, you want to see quick results without concerning code-style or any architectural things, Go gives you the oppurtinty to do your job swiftly. Not much boilerplates. Once you create the “thing”, you see that the program is actually fast, reliable and easy to distribute. You don’t need much effort to turn it into an actual product. I had an idea of making a Go client of <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">tldr-pages</a>. Altough there are plenty of same clients, I had a different idea to make it more and more user-friendly. It didn’t take more than 3 nights to create minimum viable product. When I published the pre-release version at third night, the repository had 9 commits and roughly 700 lines of code. It was nearly a ready product and when I showcased in some subreddits such as r/linux or r/golang it quickly took attention. It was very easy to create executable binaries via go build, so I wrote a bash script to create binaries for every mainstream platform and architecture. The script also compresses the files, runs a sha256 checksum and writes to a file. The <a href="https://gist.github.com/isacikgoz/72bf1c48728cded3230023d20ebd7069" target="_blank" rel="noopener">script</a> is also 40 lines of code. The project development was blazing fast, I had an idea and created a tool that is actually distributable and had positive feedback from the community. And I was not the pioneer of the idea of tldr-pages. Maybe the 50. client.</p><p>So what about the actual product? (<a href="https://github.com/isacikgoz/tldr" target="_blank" rel="noopener">tldr++</a>) It is easily integrated to CI process, adopted from community and become a very user-friendly client. Also, performance-wise it is the fastest client. And offers much more functionality than others. The actual performance results are shown in the table below:</p><table><thead><tr><th>benchmarking</th><th>Go</th><th>C++</th><th>Rust</th><th>bash</th><th>node</th></tr></thead><tbody><tr><td></td><td><a href="https://github.com/isacikgoz/tldr" target="_blank" rel="noopener">tldr++</a></td><td><a href="https://github.com/tldr-pages/tldr-cpp-client" target="_blank" rel="noopener">cpp-client</a></td><td><a href="https://github.com/dbrgn/tealdeer" target="_blank" rel="noopener">tealdeer</a></td><td><a href="https://github.com/raylee/tldr" target="_blank" rel="noopener">tldr</a></td><td><a href="https://github.com/tldr-pages/tldr-node-client" target="_blank" rel="noopener">node-client</a></td></tr><tr><td>time</td><td>5.273 ms</td><td>6.468 ms</td><td>11.59 ms</td><td>77.13 ms</td><td>415.9 ms</td></tr><tr><td></td><td>0.973 R²</td><td>0.937 R²</td><td>0.971 R²</td><td>0.815 R²</td><td>0.997 R²</td></tr><tr><td>mean</td><td>6.247 ms</td><td>5.889 ms</td><td>11.39 ms</td><td>59.26 ms</td><td>396.1 ms</td></tr><tr><td>std dev</td><td>1.203 ms</td><td>930.1 μs</td><td>1.170 ms</td><td>17.87 ms</td><td>15.89 ms</td></tr><tr><td>variance introduced by outliers</td><td>86%</td><td>78%</td><td>52%</td><td>81%</td><td>19%</td></tr><tr><td>app version</td><td>v 0.3</td><td>v 1.3.0</td><td>v 1.1.0</td><td>-</td><td>v 3.2.6</td></tr><tr><td>lines of code</td><td>~1.1K</td><td>~2.5K</td><td>~3K</td><td>~300</td><td>~4.5K</td></tr></tbody></table><p><br><br>bench v 1.0.12 is used for benchmarking and hardware details are: </p><ul><li>cpu: Intel(R) Xeon(R) CPU E5-2637 v2 @ 3.50GHz,</li><li>ram: 128GB DDR3 RAM,</li><li>disk: SSD, 550/500(r/w)</li></ul><p>As a matter of fact, tldr++ is being the one of the most popular client right now. For this amount of time its success means a lot to me. You can see its growth of popularity in time below.<br><a href="https://starcharts.herokuapp.com/isacikgoz/tldr" target="_blank" rel="noopener"><img src="https://starcharts.herokuapp.com/isacikgoz/tldr.svg" alt="Stargazers over time"></a></p><p>I really enjoyed working with Go and had pure satisfaction of creating something at this speed. Now, I have two side-projects with Go and I’m counting time to get home and work on them. I would like to thank to Go communtiy to make this happen.</p><p>tldr; if you have an idea, with the momentum of its community Go is a great tool to make it happen swiftly!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
